---
lang: zh-CN
title: 字符串匹配算法
description:
article: false
date: 2023-11-09
order: 14
---

## 1. 单模式串匹配算法

单模式串匹配，就是一个串跟一个串进行匹配。

首先介绍两种简单好理解的，BF 算法和 RK 算法。RK 算法是 BF 算法的改进，借助了哈希算法，让匹配效率有了很大提升。

然后介绍两种相对较难理解、但更高效的算法：BM 算法和 KMP 算法。

首先介绍两个概念：主串、模式串。比如我们在字符串 A 中查找字符串 B，那么 A 就是主串，B 就是模式串。下面假设主串长度是 n，模式串长度是 m。

### 1.1 BF 算法

BF 是 Brute Force 的缩写，即暴力匹配算法，也叫朴素匹配算法。

它的做法很暴力，直接在主串中，检查起始位置分别为 0, 1, 2, ..., n-m，且长度为 m 的 n-m+1 个子串，看看有没有跟模式串匹配的。

最坏情况下每次要比对 m 个字符，最多比对 n-m+1 次，所以这种算法的最坏情况时间复杂度是 $O(mn)$。

但实际上，每次对比时，遇到不匹配的字符就可以停止了，不需要把 m 个字符都进行比对。所以统计意义上，大部分情况下，算法的执行效率也比 $O(mn)$ 要好。另外，这个算法思想简单，代码实现简单。在满足性能要求前提下，简单是首选。

### 1.2 RK 算法

RK 算法的全称叫 Rabin-Karp 算法（发明者 Rabin 和 Karp）。它是 BF 算法的改进版，使用哈希算法来优化字符串比对。

使用哈希算法对主串中的 n-m+1 个子串分别求哈希值（哈希到一个数字），逐个与模式串的哈希值比较大小。

通过哈希算法计算子串的哈希值时，仍需要遍历子串中的每个字符。尽管模式串与子串比较的效率提高了，但是，算法整体的效率并没有提高。这一部分的优化可以通过哈希算法的设计来实现。

假设要匹配的字符串中的字符集只包含 K 个字符，那么就可以用 K 进制数来表示一个子串，其对应的十进制数就作为子串的哈希值。

在计算 K 进制对应的十进制时，相邻两个子串的哈希值是有关联的。用 $h[i-1]$ 和 $h[i]$ 来表示两个相邻子串的哈希值，有 $h[i] = (h[i-1] - S[i-1] \times K^{m-1}) \times K + S[i+m-1] \times K^0$。

另外，对 $K^{m-1}$ 的计算也可以提前算好，存在一个长度为 m 的数组中。

- 时间复杂度：RK 算法包括两部分，计算子串哈希值、模式串哈希值与子串哈希值之间的比较。第一部分可以通过特殊的哈希算法，扫描一遍主串就可以得到全部子串的哈希值，这部分时间复杂度是 $O(n)$；第二部分是数值之间的对比，每次只需 $O(1)$，最多进行 n-m+1 次比对，所以时间复杂度也是 $O(n)$。于是整体的时间复杂度是 $O(n)$。

### 1.3 BM 算法

对于文本编辑器，如在 Word 中把一个词全部替换成另外一个词。使用 BF 和 RK 算法就太慢了。

下面来介绍 Boyer-Moore 算法，它是一种非常高效的字符串匹配算法，有实验统计，它的性能是著名的 KMP 算法的 3 到 4 倍。但是它的原理很复杂。

#### **1. 核心思想**

BF 和 RK 算法在进行匹配时，每次模式串往后滑动一位，然后从模式串的第一个字符开始重新匹配。

如果能多滑动几位，效率就会提高。BM 算法就是要找到一种固定的规律，可以将模式串多往后滑动几位。

#### **2. 原理分析**

BM 算法两部分：坏字符规则（bad character rule）、好后缀规则（good suffix shift）。

1. 坏字符规则

首先，BM 进行子串的匹配时，是倒着匹配的（下标由大到小）。当发现某个字符没有匹配时，就称这个没有匹配的字符为**坏字符**（主串中的字符），模式串中对应的下标记作 si。

接着，拿坏字符在模式串中查找，如果模式串中没有这个字符（即，该字符与模式串中的任意字符都无法匹配），那么可以直接将模式串滑动到这个坏字符后面。然后再从模式串的末尾开始比较。

如果坏字符在模式串中存在，那么可以让这个坏字符和模式串中的该字符对齐。然后再从模式串的末尾开始比较。

把在模式串中找到的这个坏字符下标记作 xi（不存在则为 -1）。那么模式串往后滑动的位数就是 si - xi。如果坏字符在模式串中出现多次，选择==靠后==的那个（即从后往前查找），避免略过可能匹配的情况。

利用坏字符规则，BM 算法在最好情况下的时间复杂度非常低，是 $O(n/m)$。

不过，单纯使用坏字符规则还是不够的。因为根据 si-xi 计算出来的移动位数，有可能是负数，比如主串是 aaaaaaaaaaaaaaaa，模式串是 baaa。不但不会向后滑动模式串，还有可能倒退。所以，BM 算法还需要用到“好后缀规则”。

2. 好后缀规则

好后规则和上面的坏字符规则思路相似。

如下图，滑动到当前位置时，已经匹配的 bc 叫做好后缀，记作 {u}。

<div align=center>
    <img src=/images/code/ds/bm-gss.webp width=70%/>
</div>

拿 {u} 在模式串中查找，如果找到了匹配的子串{u*}，就将模式串滑动到 {u*} 与 {u} 对齐的位置。

如果没有找到，就直接将模式串滑动到主串 {u} 的后面。但这样可能出现过度滑动的情况（错过可以匹配的字符串）。我们还需要关注好后缀的后缀子串，是否存在跟模式串的前缀子串匹配的情况。

<div align=center>
    <img src=/images/code/ds/bm-gss2.webp width=70%/>
</div>

<div align=center>
    <img src=/images/code/ds/bm-gss3.webp width=70%/>
</div>

当模式串和主串中的某个字符不匹配时，如何是选择滑动位数呢？可以分别计算好后缀、坏字符画的的位数，取二者中的最大值。

#### **3. 代码实现**

坏字符规则中，找 xi 时，如果顺序遍历就比较低效。这里可以用散列表，将模式串中的每个字符及其对应的下标存到散列表中。

假设字符集不是很大，用长度为 256 的数组来记录每个字符在模式串中最后出现的位置。

```js
const SIZE = 256; // Global constant
const bc = new Array(SIZE).fill(-1); // 用于坏字符匹配

// b 模式串，m 模式串长度，bc 散列表
function generateBC(b, m) {
  for (let i = 0; i < m; ++i) {
    const ascii = b.charCodeAt(i);
    bc[ascii] = i;
  }
}
```

实现好后缀规则，它要处理：

- 在模式串中，查找跟好后缀匹配的另一个子串；
- 在好后缀的后缀子串中，查找最长的、能跟模式串前缀子串匹配的；

由于好后缀也是模式串本身的后缀子串，所以我们只需使用模式串：我们可以预先计算出模式串的每个后缀子串，所对应的另一个可匹配子串的位置。

模式串中的后缀子串的长度唯一确定了该串，所以可以用长度来表示后缀子串。这里我们引入最关键的变量 suffix 数组。下标 k 表示后缀子串的长度，对应的数值表示的是：在模式串中跟该后缀子串（也就是好后缀）{u} 相匹配的子串 {u\*} 的起始下标（如果有多个 {u\*}，则使用最后一个）。

另外，我们还要处理好后缀的后缀子串（与模式串前缀子串进行匹配）。我们再引入一个 prefix 数组，它存储的是 boolean 值，记录模式串的后缀子串是否能匹配模式串的前缀子串。

<div align=center>
    <img src=/images/code/ds/bm-suffix-prefix.webp width=70%/>
</div>

模式串的前缀子串、与整个模式串，求他们的公共后缀子串。如果这个公共后缀子串的长度是 k，就记录 suffix[k] = j。如果 j 是 0，表明这个公共后缀子串也是模式串的前缀子串，就记录 prefix[k] = true。

<div align=center>
    <img src=/images/code/ds/bm-suffix-prefix-imp.webp width=70%/>
</div>

```js
const suffix = new Array(m).fill(-1);
const prefix = new Array(m).fill(false);

function generateGS(b, m, suffix, prefix) {
  // 从 0 到 i 的前缀子串，和整个模式串，找公共后缀子串
  for (let i = 0; i < m - 1; ++i) {
    let j = i; // 前缀子串中，后缀子串的初始下标
    let k = 1; // 公共后缀子串的长度
    while (j >= 0 && b[j] === b[m - k]) {
      suffix[k] = j;
      --j;
      ++k;
    }
    if (j === -1) {
      prefix[k] = true;
    }
  }
}
```

BM 算法:

```js
// a 主串，n 主串长度；b 模式串，m 模式串长度
function bm(a, n, b, m) {
  generateBC(b, m, bc);
  generateBC(b, m, suffix, prefix);

  let i = 0; // 主串中，与模式串对齐的第一个字符的位置
  while (i <= n - m) {
    let j;
    for (j = m - 1; j >= 0; --j) {
      // 模式串从后往前匹配
      if (a[i + j] !== b[j]) break; // 坏字符下标是 j
    }
    if (j < 0) return i; // 匹配成功，返回主串中与模式串匹配的第一个字符位置

    let x = j - bc[a.charCodeAt(i + j)]; // 1. 坏字符规则要移动的位数
    let y = 0;
    if (j !== m - 1) {
      // 如果有好后缀，j !== m-1
      y = moveByGS(j, m); // 2. 好后缀规则要移动的位数
    }
    i = i + Math.max(x, y);
  }

  return -1;
}

function moveByGS(j, m) {
  let k = m - 1 - j; // 好后缀的长度
  if (suffix[k] !== -1) return j - suffix[k] + 1;

  for (let r = j + 2; r <= m - 1; ++r) {
    if (prefix[m - r] === true) {
      return r;
    }
  }
  return m;
}
```

#### **4. 性能分析**

空间方面，整个算法用到了额外的三个数组，散列表 bc 的大小与字符集大小有关，suffix 数组和 prefix 数组跟模式串长度 m 有关。

如果字符集很大，bc 消耗就比较多。如果我们运行的环境堆内存要求苛刻，可以只使用好后缀，不使用坏字符，这样就避免了 bc 数组的内存消耗。但这样的话，BM 算法的效率就会下降一些。

时间方面，在极端情况下预处理 suffix 数组、prefix 数组的性能会比较差。比如模式串是 aaaaaaa 这种包含很多重复的字符的模式串，预处理的时间复杂度就是 $O(m^2)$。

### 1.4 KMP 算法

KMP 的名字源自它的三位作者 D.E.Knuth，J.H.Morris 和 V.R.Pratt。

类比 BM 算法，有坏字符、好前缀的概念。

当遇到坏字符时，模式串要在主串中向后滑动。滑动过程的比对就相当于：好前缀的后缀子串与模式串的前缀子串的比较。

> 好前缀和模式串前面是匹配的。所以，在编码时，我们只需要用到模式串本身。在模式串的后缀子串中，找到最长的、能和模式串的前缀子串匹配的。

如下图，当找到对应的匹配时，要把模式串向后滑动 j-k 位（j 更新为 k，i 不变），继续比较。

<div align=center>
    <img src=/images/code/ds/kmp_move.webp width=70%/>
</div>

类似 BM 在处理好后缀时用到 suffix、prefix 数组，KMP 也可以构建一个 next 数组。下标是每个前缀（每个前缀都可能是好前缀）最后一个字符的下标，对应的值是这个前缀的最长可匹配的前缀子串的结尾字符下标。很多书中还给这个数组起了一个名字，叫失效函数（failure function）。

<div align=center>
    <img src=/images/code/ds/kmp_next.webp width=70%/>
</div>

## 2. 多模式串匹配算法
