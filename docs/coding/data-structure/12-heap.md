---
lang: zh-CN
title: 堆
description:
article: false
date: 2023-09-25
order: 12
---

堆是一种特殊的树。如果一个树满足以下两点要求，那它就是一个堆。

- 堆是一个完全二叉树；
- 堆中每个节点的值，都必须大于等于（或小于等于）其子树中每个节点的值。

由于堆是一个完全二叉树，可以使用数组来存储堆（下标从 1 开始）。

## 1. 堆化

当我们在数组最后插入一个元素后，可能会不符合堆的性质，于是需要将其调整至满足堆的性质，这个过程叫做堆化（heapify）。堆化有两种方式，从下往上或从上往下。

堆化很简单，就是顺着节点所在路径，向上或者向下，对比，然后交换，直至不需要交换或到达根节点为止。

### 1.1 插入元素

插入时采用==从下往上==的堆化方式。

```java
public class Heap {
  private int[] a;    // 堆，下标从 1 开始
  private int n;      // 堆能存储的最大数据个数
  private int count;  // 堆中已存的数据个数

  public Heap(int capacity) {
    a = new int[capacity+1];
    n = capacity;
    count = 0;
  }

  public void insert(int data) {
    if (count >= n) return;   // 堆已满
    ++count;
    a[count] = data;
    int i = count;
    while (i/2 > 0 && a[i] > a[i/2]) {
      swap(a, i, i/2);      // 交换下标为 i 和 i/2 的元素
      i = i/2;
    }
  }
}
```

### 1.2 删除堆顶元素

大顶堆（或小顶堆）中的堆顶元素就是堆中的最大值（或最小值）。

我们采用==从上到下==的方式进行堆化。删除堆顶后，将堆的最后一个节点放到堆顶。然后进行父子节点对比，不满足条件的则交换两个结点，重复进行这个过程直至满足大小关系。

```java
// 删除大顶堆的堆顶元素
public removeMax() {
  if (count == 0) return -1;  // 堆中无数据
  a[1] = a[count];
  --count;
  heapify(a, count, 1);
}

// 从上往下堆化
private void heapify(int[] a, int n, int i) {
  while (true) {
    int maxPos = i;
    // 找左右子树最大的下标
    if (i*2 <= n && a [i] < a[i*2]) maxPos = i*2;
    if (i*2+1 <= n && a [maxPos] < a[i*2+1]) maxPos = i*2+1;
    if (maxPos == i) break;

    swap(a, i, maxPos);
    i = maxPos;
  }
}
```

## 2. 堆排序

堆排序时间复杂度很稳定，是 $O(nlogn)$，且是原地排序。堆排序的过程分为两步：建堆和排序。

### 2.1 建堆

建堆有两种思路。

一种是借助上文所讲的在堆中插入一个元素。这种思路是从前往后处理数据，每个数据插入堆中时，都从下往上堆化。

第二种思路正相反，从后往前处理数据，每个数据都是从上往下堆化。

由于叶子节点向下堆化只能跟自己比较，所以直接从最后一个非叶子节点（下标为 $\lfloor n/2 \rfloor$）开始，依次堆化。注意每次堆化要比较到无需交换或者到达叶子节点。

```java
private static void buildHeap(int[] a, int n) {
  for (int i = n/2; i >= 1; --i) {
    heapify(a, n, i)
  }
}

// 从上往下堆化，同上
private static void heapify(int[] a, int n, int i) {
  while (true) {
    int maxPos = i;
    if (i*2 <= n && a[i] < a[i*2]) maxPos = i*2;
    if (i*2+1 <= n && a[maxPos] < a[i*2+1]) maxPos = i*2+1;
    if (maxPos == 1) break;

    swap(a, i, maxPos);
    i = maxPos;
  }
}
```

建堆的时间复杂度是 $O(n)$。

### 2.2 排序

大顶堆建堆完成之后，堆顶就是最大元素，将其和最后一个元素交换。最后一个元素被放到了堆顶，再通过堆化的方式，将剩下的 n - 1 个元素重新构建成堆。然后再取堆顶，和最后一个元素交换，堆化。直至堆中只剩下一个元素，排序就完成了。

```java
public static void sort(int[] a, int n) {
  buildHeap(a, n);
  int k = n;
  while (k > 1) {
    swap(a, k, 1);
    --k;
    heapify(a, k, 1);
  }
}
```

堆排序包括建堆和排序两个操作，建堆时间复杂度是 $O(n)$，排序过程的时间复杂度是 $O(nlogn)，所以堆排序的时间复杂度是 $O(nlogn)$。

堆排序不是稳定的排序算法，因为排序过程中存在将堆顶和堆的最后一个节点的互换操作，有可能改变相同值的原始相对顺序。

### 2.3 堆排序 v.s. 快速排序

快速排序要比堆排序的性能好。

- 堆排序数据访问方式没有快速排序友好。

  快速排序中，数据是顺序访问的；而堆排序中，数据是跳着访问的。

- 同样的数据，堆排序算法的数据交换次数多于快速排序。

  对于基于比较的排序来说，整个排序过程就是两个基本操作组成的：比较和交换（或移动）。快速排序数据交换的次数不会比逆序度多。

  而堆排序的第一步是建堆，建堆会打乱原始数据的相对先后顺序，导致数据的有序度降低。

## 3. 堆的应用

除了堆排序，堆还有很多应用。

### 3.1 优先级队列

队列往往是先进先出，而优先级队列的出队顺序不是先进先出，而是按照优先级，优先级最高的最先出队。

实现优先级队列的方法有很多，用堆来实现是最直接、最高效的。

优先级队列的应用场景非常多，比如，赫夫曼编码、图的最短路径、最小生成树算法等。很多语言都提供了优先级队列的实现，比如 Java 的 PriorityQueue，C++ 的 priority_queue 等。

#### 3.1.1 合并有序小文件

场景：100 个小文件，每个文件 100MB，每个文件中存储的都是有序的字符串。要把这些小文件合并成一个有序的大文件。

如果采用类似归并排序中的合并函数，使用数组来存放每次取出的 100 个字符，需要遍历这个长度为 100 的数组。

更高效的方式是使用优先级队列（堆）。将从每个小文件中取出的字符放到小顶堆中，那么堆顶元素就是最小字符串。将其放到大文件中，并将其从堆中删除，然后从对应的小文件中取下一个字符放到堆中。

在堆中插入和删除数据的时间复杂度都是 $O(logn)$，相比于使用数组的方式高效了很多。

#### 3.1.2 高性能定时器

场景：有一个定时器，维护了很多定时任务，每个任务都设定了要触发执行的时间。

如果定时器每过一小段时间（比如 1s）就扫描一遍任务列表，若有任务到了触发时间就执行。这样的方式比较低效，可能任务要执行的时间还有很久，这样会有很多无效扫描；如果任务列表太大的话，每次遍历比较耗时。

使用优先级队列可以解决这些问题。将任务按照执行时间存储在优先级队列中，小顶堆堆顶存储最先执行的任务。取优先级队列队首的执行时间点，减去当前时间，得到时间间隔 T。于是定时器就可以设定，在时间 T 后再来执行任务。

这样，定时器既不用间隔 1 秒就轮询一次，也不用遍历整个任务列表，性能也就提高了。

### 3.2 Top K

1. 静态数据

问题：在无序数组中查找前 K 大数据。

思路：维护一个大小为 K 的小顶堆，顺序遍历数组，将从数组中取得的元素与堆顶元素比较：如果比堆顶元素大，就把堆顶元素删除，并将该元素插入到堆中；如果比堆顶元素小，就不做处理。遍历完之后，堆中的数据就是前 K 大数据，堆顶元素就是第 K 大的数据。

> 之前还介绍过[用快速排序分区的方式查找无需数组中的第 K 大元素](/coding/data-structure/7-sort.html#_2-3-思想-分治)，时间复杂度是 $O(n)$。

时间复杂度：遍历数组 $O(n)$，一次堆化 $O(logK)$，最坏情况下 n 个元素都入堆，于是时间复杂度就是 $O(nlogK)$。

2. 动态数据

一个数据集合有两个操作，一个是添加数据，一个是访问当前的前 K 大数据。

如果每次都基于当前数据重新计算前 K 大数据，太过麻烦。同上，我们可以一直维护一个大小为 K 的小顶堆，当数据被添加到集合中时，就将其和堆顶元素比较：如果比堆顶元素大，就删除堆顶，插入该元素；如果比堆顶小，就不做处理。

### 3.3 求中位数

如果数据个数 n 是奇数，那么中位数是第 $\lfloor \frac{n}{2} \rfloor + 1$ 个;

如果是偶数，那么中间元素是第 $\frac{n}{2}$ 和第 $\frac{n}{2}+1$ 个。

静态数据可以先排序，再去找对应的元素。但是动态数据，如果每次数据变动都先排序再取中位数，效率就不高了。我们可以借助堆来实现。

1. 思路

维护两个堆，一个大顶堆和一个小堆顶。这样大顶堆中就存储前半部分数据（小的那半部分），而小顶堆中存储后半部分数据（大的那半部分）。

如果 n 是奇数，升序后的数据中，前 $\lfloor \frac{n}{2} \rfloor + 1$ 个数据在大顶堆中（后 $\frac{n}{2}$ 在小顶堆中）。大顶堆的堆顶就是中位数。

如果 n 是偶数，升序后的数据中，前 $\frac{n}{2}$ 在大堆顶中，后 $\frac{n}{2}$ 在小顶堆中。大顶堆的堆顶、小顶堆的堆顶就是中位数。

2. 具体实现

如果新加入的数据，小于等于大顶堆的堆顶，就将其插入大顶堆；否则，就插入小顶堆。

如果插入之后，两个堆的数据个数不符合上面的要求，就将堆顶元素移动到另一个堆。

3. 时间复杂度：$O(logn)$

同理，利用堆可以快速求其他百分位的数据。
