---
lang: zh-CN
title: 内存
description:
article: false
date: 2024-08-01
order: 1
---

## 1. 内存

先看这样一个例子：

```rust
let s = "hello world".to_string();
println!("addr of ss: {:p}, s: {:p}, len: {}, capacity: {}, size: {}",
        &"hello world", &s, s.len(), s.capacity(), std::mem::size_of_val(&s));
println!("字符串常量获得固定的内存地址 {:p}", &"hello world")

// addr of ss: 0x5562fb6903f8, s: 0x7fff7db37d58, len: 11, capacity: 11, size: 24
// 字符串常量获得固定的内存地址 0x5562fb6903f8
```

1. “hello world” 是字符串常量（string literal），在编译时被存入可执行文件的 .RODATA 段（GCC）或 .RDATA 段（VC++）。程序加载时，会获得一个固定的内存地址。

2. 执行 `"hello world".to_string()` 时，在堆上分配新的内存，把 “hello world” 逐字节拷贝过去。

3. 把堆上的数据复制给 `s` 时，`s` 作为分配在栈上的变量，它需要知道堆上对应的内存地址。由于堆上的数据大小不确定且可以增长，所以还需要知道它的长度以及它现在有多大。

如下图所示，为了表达这个字符串使用了 3 个字（word）：指针、字符串当前长度（11）、对应内存的容量（11）。在 64 位系统下，三个 word 是 24 字节。

![](/images/rust/memory.webp =500x)

## 2. 栈和堆

### 2.1 栈

栈是程序运行的基础。栈帧是分配在调用栈（Call Stack）上的一块内存区域，当一个函数被调用时，一块连续的内存就会在栈顶被分配出来，这块内存被称为栈帧（Stack Frame）。

栈自顶向下增长，一个程序调用战斗的最底部，除去入口帧（entry frame），就是 main() 函数对应的帧。随着函数一层层嗲用，栈会一层层扩展；调用结束，栈又会一层层回溯，释放内存。

![](/images/rust/callstack.webp =500x)

某个栈帧要有多大呢？编译器在编译并优化代码时，一个函数就是一个最小的编译单元。在一个函数中，编译器必须知道要用到哪些寄存器、栈上要放哪些局部变量，这些都在编译时确定，以便预留空间。

所以，**在编译时，一切无法确定大小或者大小可以改变的数据，都无法安全地放在栈上，最好放在堆上。**

#### 栈的使用

栈上的内存分配是非常高效的：改动栈指针（Stack Pointer）就可以预留相应的空间；把栈指针改回来，预留的空间就会被释放掉。预留和释放只是改动寄存器，不涉及额外计算、不涉及系统调用，效率很高。

所以，在保证栈空间足够的前提下，应尽可能使用栈内存来换高性能执行。比如很多内存分配模块都提供了可选地内训位置，如栈、固定大小的内存池（来自于堆）。

但是在实际工作中，考虑到调用栈的大小，避免栈溢出（Stack Overflow），我们又要避免把大量的数据分配在栈上。

### 2.2 堆

#### 2.2.1 动态大小的内存分配到堆上

当需要动态大小的内存时，只能使用堆。如可变长度的数组、列表、哈希表、字典等。

堆上分配内存时，一般都会预留一些空间，这是最佳实践。

比如创建一个列表

```rust
let mut arr = Vec::new();
arr.push(1);
arr.push(2);
```

这个列表实际预留的大小是 4，而不是其长度 2。如果不预留空间、需要多少就分配多少，那么每次新增值，都要新分配一大块内存，先拷贝已有数据，再把新值加进去，最后释放旧的内存。这样效率很低。

> 堆上内存分配会使用 libc 提供的 malloc() 函数，其内部会请求操作系统的系统调用来分配内存。系统调用代价高昂，我们要避免频繁使用 malloc()。

#### 2.2.1 动态生命周期的内存分配到堆上

栈帧会在函数调用结束后被回收，相关变量对应的内存也都被回收。所以栈上内存的生命周期是不受开发者控制的，并且局限在当前调用栈。

而堆上分配出的每一块内存需要显示释放，于是堆上内存有更灵活的生命周期，可以在不同的调用栈之间共享数据。

#### 堆的使用

堆内存的灵活性也给内存管理带来很多挑战。

如果手工管理堆内存的话，堆上内存分配后忘记释放，就会造成**内存泄漏**。

如果堆上内存被多个线程的调用栈引用，该内存的改动要特别小心，需要加锁以独占访问，来避免潜在的问题。比如说，一个线程在遍历列表，而另一个线程在释放列表中的某一项，就可能访问野指针，导致**堆越界**（heap out of bounds）。而堆越界是第一大内存安全问题。

如果堆上内存被释放，但栈上指向堆上内存的相应指针没有被清空，就有可能发生**使用已释放内存**（use after free）的情况，程序轻则崩溃，重则隐含安全隐患。根据[微软安全反应中心（MSRC）的研究](https://github.com/Microsoft/MSRC-Security-Research/blob/master/presentations/2019_02_BlueHatIL/2019_01%20-%20BlueHatIL%20-%20Trends%2C%20challenge%2C%20and%20shifts%20in%20software%20vulnerability%20mitigation.pdf)，这是第二大内存安全问题。

## 3. 垃圾回收

### GC 和 ARC

为了避免堆内存手动管理造成的问题，以 Java 为首的一系列编程语言，采用追踪式垃圾回收（[Tracing GC](https://zh.javascript.info/garbage-collection#nei-bu-suan-fa)）方法来自动管理内存。通过定期标记（mark）找出不可达对象，然后将其清理（sweep）掉。

ObjC 和 Swift 则使用自动引用计数（Automatic Reference Counting）方法。在编译时，为每个函数插入 retain/release 语句来自动维护堆上对象的引用计数，当引用计数为零时，release 语句就释放对象。

### 对比

效率上，GC 在内存分配和释放上没有额外操作。而 ARC 添加了大量额外代码来处理引用计数。所以 GC 效率更高，吞吐量（throughput）更大。

但是，GC 释放内存的时机不确定，释放时引发的 STW（Stop the World）也会导致代码执行的延迟（latency）不确定。所以，**一般携带 GC 的编程语言，不适合做嵌入式系统或实时系统**。

使用 Android 手机偶尔感觉卡顿，而 iOS 却运行丝滑，大多是这个原因。而且做后端服务时，API 或者服务响应时间的 p99（99th percentile，一组数据中最差的 1% 的情况）也会受到 GC STW 的影响而表现不佳。

GC 分配和释放内存的效率和吞吐量要比 ARC 高，**但因为偶尔的高延迟，导致被感知的性能比较差**，所以会给人一种 GC 不如 ARC 性能好的感觉。

## 小结

- 栈中存放的数据是静态的、固定大小、固定生命周期；堆上存放的数据是动态的、不固定大小、不固定生命周期。
  - 对于存入栈的值，它的大小在编译时就要确定。栈上存储的变量，生命周期在当前调用栈的作用域内，无法跨调用栈引用。
  - 堆可以存入大小未知或动态伸缩的数据类型。堆上存储的变量，起盛宁周期从分配后开始，一直到释放时才结束。因此堆上的变量允许在多个调用栈之间引用。但也导致堆变量的管理非常复杂，手工管理会引发很多内存安全性问题，而自动管理，无论是 GC 还是 ARC，都有性能损耗和其它问题。
