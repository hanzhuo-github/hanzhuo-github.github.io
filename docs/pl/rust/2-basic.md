---
lang: zh-CN
title: 基本概念
description:
article: false
date: 2024-08-02
order: 2
---

## 1 数据

### 1.1 数据和类型

![](/images/rust/datastructure.webp =500x)

### 1.2 指针和引用

指针即内存地址，可以通过解引用（dereference）来访问它指向的内存地址。理论上可以解引用到任意数据类型。

引用（reference）类似指针。不同之处在于，引用的解引用访问受限，只能解引用到它引用数据的类型。如 42u8 这个值的引用，它解引用只能使用 u8 数据类型。

指针和引用是原生类型，可以分配在栈上。

某些引用除了一个指针指向内存地址外，还需要内存地址的长度和其他信息。比如上节中的 “hello world” 字符串的指针，还包含字符串长度和字符串的容量。这样比正常指针携带更多信息的指针，称为**胖指针**（fat pointer）。很多数据结构的引用，内部都是通过胖指针实现的。

## 2 代码

### 2.1 函数、方法、闭包

参考 JavaScript 中的[闭包](/front-end/js/closure.md)。

### 2.2 接口和虚表

作为一个抽象层，接口将使用方（client）和实现方（implementation）隔离开来，使两者不直接有依赖关系，大大提高了复用性和扩展性。

使用接口类型的变量可以引用任何实现该接口的具体类型，具体行为是在运行时决定的，而非编译时就固定下来的。

```java
interface Animal {
  void sound();
}

class Dog implements Animal {
  public void sound() {
    System.out.println("Bark");
  }
}

class Cat implements Animal {
  public void sound() {
    System.out.println("Meow");
  }
}

// 运行时
Animal myAnimal = new Dog();
myAnimal.sound();  // Bark
```

但是，使用接口时，具体对象的类型信息倍隐藏，只能通过接口提供的方法来操作这个对象。如上面代码中的 `myAnimal`，是 `Animal` 类型的引用，指向一个 `Dog` 对象。但是，一旦我们使用 `Animal` 接口来引用它，我们就无法从 `myAnimal` 这个引用本身得值它实际上引用的是 `Dog` 类型的对象。这倍称为类型抹除（Type Erasure）。

我们无法仅仅通过这样一个指针分析出这个引用具备什么能力。因此，**在生成这个引用的事后，我们需要构建胖指针，除了指向数据本身外，还需要指向一张涵盖了这个接口所支持方法的列表**。这个列表，就是**虚表**（Virtual Table）。

<!-- // LEARN: learn this -->

## 3 运行方式

### 3.1 并发（concurrency）与并行（parallel）

并发是多件事情来回切换；并行使同事处理多件事情，多个任务可以在同一个时间片下工作，无需上下文切换。

**并发是一种能力，而并行是一种手段**。并行是基于硬件的，而并发是可以通过设计编码提高。所以我们平时谈的大多是高并发处理，而不会说高并行处理。

### 3.2 同步和异步

同步是指，一个任务开始执行后，后续的操作会被阻塞，直到这个任务结束。它保证的代码的因果关系（causality），是程序正确性的保证。

异步是指，一个任务开始执行后，与它没有因果关系的其他任务可以正常执行，不必等该任务结束。

异步处理后的结果一般用 `Promise` 来保存，该对象描述在未来某个时刻才能获得的结果的值，一般存在三种状态：

1. 初始状态，Promise 还未运行；
2. 等待（Pending）状态，Promise 已经运行，但是还未结束；
3. 结束状态，Promise 成功解析出一个值，或者执行失败。

一般而言，**async 定义了一个可以并发执行的任务，而 await 则触发这个任务并发执行**。大多数语言中，async/await 是一个语法糖（syntactic sugar），它使用状态机将 Promise 包装起来，让异步调用的使用感觉和同步调用非常类似，也让代码更容易阅读。

## 4 编程范式

提升代码质量：泛型编程

### 4.1 数据结构的泛型

数据结构的泛型，也被称为参数化类型、参数多态。它带来的好处是可以进行延迟绑定，让数据结构的通用性更强。

```rust
struct Connection<S> {
  io: S,
  state: State,
}
```

它有一个参数 S，其内部的域 io 的类型是 S，S 具体的类型只有在使用 Connection 的上下文中才被绑定。

这就会产生一个问题。S 可以是任何类型，那开发者怎么知道 S 有什么行为？如果要调用 `io.send()` 发送数据，编译器怎么知道 S 包含这个方法？

**我们需要用接口对 S 进行约束**。所以说，一般支持泛型变成的语言，会提供强大的接口编程能力，后续学到 Rust 的 trait 时会详细探讨这个问题。

### 4.2 代码的泛型化

![](/images/rust/codegeneric.webp =600x)

## 小结

![](/images/rust/basicsum.webp =600x)
