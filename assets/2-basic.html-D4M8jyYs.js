import { r as resolveComponent, c as createElementBlock, b as createStaticVNode, f as createBaseVNode, g as createTextVNode, d as createVNode, e as withCtx, a as createCommentVNode, o as openBlock } from "./app-DERZZvM1.js";
import { _ as _export_sfc } from "./plugin-vue_export-helper-1tPrXgE0.js";
const _imports_0 = "/images/rust/datastructure.webp";
const _imports_1 = "/images/rust/codegeneric.webp";
const _imports_2 = "/images/rust/basicsum.webp";
const _sfc_main = {};
function _sfc_render(_ctx, _cache) {
  const _component_RouteLink = resolveComponent("RouteLink");
  return openBlock(), createElementBlock("div", null, [
    _cache[3] || (_cache[3] = createStaticVNode('<h2 id="_1-数据" tabindex="-1"><a class="header-anchor" href="#_1-数据"><span>1 数据</span></a></h2><h3 id="_1-1-数据和类型" tabindex="-1"><a class="header-anchor" href="#_1-1-数据和类型"><span>1.1 数据和类型</span></a></h3><figure><img src="' + _imports_0 + '" alt="" width="500" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_1-2-指针和引用" tabindex="-1"><a class="header-anchor" href="#_1-2-指针和引用"><span>1.2 指针和引用</span></a></h3><p>指针即内存地址，可以通过解引用（dereference）来访问它指向的内存地址。理论上可以解引用到任意数据类型。</p><p>引用（reference）类似指针。不同之处在于，引用的解引用访问受限，只能解引用到它引用数据的类型。如 42u8 这个值的引用，它解引用只能使用 u8 数据类型。</p><p>指针和引用是原生类型，可以分配在栈上。</p><p>某些引用除了一个指针指向内存地址外，还需要内存地址的长度和其他信息。比如上节中的 “hello world” 字符串的指针，还包含字符串长度和字符串的容量。这样比正常指针携带更多信息的指针，称为<strong>胖指针</strong>（fat pointer）。很多数据结构的引用，内部都是通过胖指针实现的。</p><h2 id="_2-代码" tabindex="-1"><a class="header-anchor" href="#_2-代码"><span>2 代码</span></a></h2><h3 id="_2-1-函数、方法、闭包" tabindex="-1"><a class="header-anchor" href="#_2-1-函数、方法、闭包"><span>2.1 函数、方法、闭包</span></a></h3>', 10)),
    createBaseVNode("p", null, [
      _cache[1] || (_cache[1] = createTextVNode("参考 JavaScript 中的")),
      createVNode(_component_RouteLink, { to: "/front-end/js/closure.html" }, {
        default: withCtx(() => _cache[0] || (_cache[0] = [
          createTextVNode("闭包")
        ])),
        _: 1
        /* STABLE */
      }),
      _cache[2] || (_cache[2] = createTextVNode("。"))
    ]),
    _cache[4] || (_cache[4] = createStaticVNode('<h3 id="_2-2-接口和虚表" tabindex="-1"><a class="header-anchor" href="#_2-2-接口和虚表"><span>2.2 接口和虚表</span></a></h3><p>作为一个抽象层，接口将使用方（client）和实现方（implementation）隔离开来，使两者不直接有依赖关系，大大提高了复用性和扩展性。</p><p>使用接口类型的变量可以引用任何实现该接口的具体类型，具体行为是在运行时决定的，而非编译时就固定下来的。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">interface</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span></span>\n<span class="line">  <span class="token keyword">void</span> <span class="token function">sound</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>\n<span class="line"><span class="token punctuation">}</span></span>\n<span class="line"></span>\n<span class="line"><span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">implements</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span></span>\n<span class="line">  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sound</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>\n<span class="line">    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Bark&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>\n<span class="line">  <span class="token punctuation">}</span></span>\n<span class="line"><span class="token punctuation">}</span></span>\n<span class="line"></span>\n<span class="line"><span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token keyword">implements</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span></span>\n<span class="line">  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sound</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>\n<span class="line">    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Meow&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>\n<span class="line">  <span class="token punctuation">}</span></span>\n<span class="line"><span class="token punctuation">}</span></span>\n<span class="line"></span>\n<span class="line"><span class="token comment">// 运行时</span></span>\n<span class="line"><span class="token class-name">Animal</span> myAnimal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>\n<span class="line">myAnimal<span class="token punctuation">.</span><span class="token function">sound</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Bark</span></span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是，使用接口时，具体对象的类型信息倍隐藏，只能通过接口提供的方法来操作这个对象。如上面代码中的 <code>myAnimal</code>，是 <code>Animal</code> 类型的引用，指向一个 <code>Dog</code> 对象。但是，一旦我们使用 <code>Animal</code> 接口来引用它，我们就无法从 <code>myAnimal</code> 这个引用本身得值它实际上引用的是 <code>Dog</code> 类型的对象。这倍称为类型抹除（Type Erasure）。</p><p>我们无法仅仅通过这样一个指针分析出这个引用具备什么能力。因此，<strong>在生成这个引用的事后，我们需要构建胖指针，除了指向数据本身外，还需要指向一张涵盖了这个接口所支持方法的列表</strong>。这个列表，就是<strong>虚表</strong>（Virtual Table）。</p>', 6)),
    createCommentVNode(" // LEARN: learn this "),
    _cache[5] || (_cache[5] = createStaticVNode('<h2 id="_3-运行方式" tabindex="-1"><a class="header-anchor" href="#_3-运行方式"><span>3 运行方式</span></a></h2><h3 id="_3-1-并发-concurrency-与并行-parallel" tabindex="-1"><a class="header-anchor" href="#_3-1-并发-concurrency-与并行-parallel"><span>3.1 并发（concurrency）与并行（parallel）</span></a></h3><p>并发是多件事情来回切换；并行使同事处理多件事情，多个任务可以在同一个时间片下工作，无需上下文切换。</p><p><strong>并发是一种能力，而并行是一种手段</strong>。并行是基于硬件的，而并发是可以通过设计编码提高。所以我们平时谈的大多是高并发处理，而不会说高并行处理。</p><h3 id="_3-2-同步和异步" tabindex="-1"><a class="header-anchor" href="#_3-2-同步和异步"><span>3.2 同步和异步</span></a></h3><p>同步是指，一个任务开始执行后，后续的操作会被阻塞，直到这个任务结束。它保证的代码的因果关系（causality），是程序正确性的保证。</p><p>异步是指，一个任务开始执行后，与它没有因果关系的其他任务可以正常执行，不必等该任务结束。</p><p>异步处理后的结果一般用 <code>Promise</code> 来保存，该对象描述在未来某个时刻才能获得的结果的值，一般存在三种状态：</p><ol><li>初始状态，Promise 还未运行；</li><li>等待（Pending）状态，Promise 已经运行，但是还未结束；</li><li>结束状态，Promise 成功解析出一个值，或者执行失败。</li></ol><p>一般而言，<strong>async 定义了一个可以并发执行的任务，而 await 则触发这个任务并发执行</strong>。大多数语言中，async/await 是一个语法糖（syntactic sugar），它使用状态机将 Promise 包装起来，让异步调用的使用感觉和同步调用非常类似，也让代码更容易阅读。</p><h2 id="_4-编程范式" tabindex="-1"><a class="header-anchor" href="#_4-编程范式"><span>4 编程范式</span></a></h2><p>提升代码质量：泛型编程</p><h3 id="_4-1-数据结构的泛型" tabindex="-1"><a class="header-anchor" href="#_4-1-数据结构的泛型"><span>4.1 数据结构的泛型</span></a></h3><p>数据结构的泛型，也被称为参数化类型、参数多态。它带来的好处是可以进行延迟绑定，让数据结构的通用性更强。</p><div class="language-rust" data-highlighter="prismjs" data-ext="rs" data-title="rs"><pre><code><span class="line"><span class="token keyword">struct</span> <span class="token type-definition class-name">Connection</span><span class="token operator">&lt;</span><span class="token class-name">S</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span></span>\n<span class="line">  io<span class="token punctuation">:</span> <span class="token class-name">S</span><span class="token punctuation">,</span></span>\n<span class="line">  state<span class="token punctuation">:</span> <span class="token class-name">State</span><span class="token punctuation">,</span></span>\n<span class="line"><span class="token punctuation">}</span></span>\n<span class="line"></span></code></pre></div><p>它有一个参数 S，其内部的域 io 的类型是 S，S 具体的类型只有在使用 Connection 的上下文中才被绑定。</p><p>这就会产生一个问题。S 可以是任何类型，那开发者怎么知道 S 有什么行为？如果要调用 <code>io.send()</code> 发送数据，编译器怎么知道 S 包含这个方法？</p><p><strong>我们需要用接口对 S 进行约束</strong>。所以说，一般支持泛型变成的语言，会提供强大的接口编程能力，后续学到 Rust 的 trait 时会详细探讨这个问题。</p><h3 id="_4-2-代码的泛型化" tabindex="-1"><a class="header-anchor" href="#_4-2-代码的泛型化"><span>4.2 代码的泛型化</span></a></h3><figure><img src="' + _imports_1 + '" alt="" width="600" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结"><span>小结</span></a></h2><figure><img src="' + _imports_2 + '" alt="" width="600" tabindex="0" loading="lazy"><figcaption></figcaption></figure>', 22))
  ]);
}
const _2Basic_html = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__file", "2-basic.html.vue"]]);
const data = JSON.parse('{"path":"/pl/rust/2-basic.html","title":"基本概念","lang":"zh-CN","frontmatter":{"lang":"zh-CN","title":"基本概念","description":null,"article":false,"date":"2024-08-02T00:00:00.000Z","order":2},"headers":[{"level":2,"title":"1 数据","slug":"_1-数据","link":"#_1-数据","children":[{"level":3,"title":"1.1 数据和类型","slug":"_1-1-数据和类型","link":"#_1-1-数据和类型","children":[]},{"level":3,"title":"1.2 指针和引用","slug":"_1-2-指针和引用","link":"#_1-2-指针和引用","children":[]}]},{"level":2,"title":"2 代码","slug":"_2-代码","link":"#_2-代码","children":[{"level":3,"title":"2.1 函数、方法、闭包","slug":"_2-1-函数、方法、闭包","link":"#_2-1-函数、方法、闭包","children":[]},{"level":3,"title":"2.2 接口和虚表","slug":"_2-2-接口和虚表","link":"#_2-2-接口和虚表","children":[]}]},{"level":2,"title":"3 运行方式","slug":"_3-运行方式","link":"#_3-运行方式","children":[{"level":3,"title":"3.1 并发（concurrency）与并行（parallel）","slug":"_3-1-并发-concurrency-与并行-parallel","link":"#_3-1-并发-concurrency-与并行-parallel","children":[]},{"level":3,"title":"3.2 同步和异步","slug":"_3-2-同步和异步","link":"#_3-2-同步和异步","children":[]}]},{"level":2,"title":"4 编程范式","slug":"_4-编程范式","link":"#_4-编程范式","children":[{"level":3,"title":"4.1 数据结构的泛型","slug":"_4-1-数据结构的泛型","link":"#_4-1-数据结构的泛型","children":[]},{"level":3,"title":"4.2 代码的泛型化","slug":"_4-2-代码的泛型化","link":"#_4-2-代码的泛型化","children":[]}]},{"level":2,"title":"小结","slug":"小结","link":"#小结","children":[]}],"git":{"createdTime":1735022911000,"updatedTime":1735022911000,"contributors":[{"name":"Hertz","username":"Hertz","email":"hanzhuosoul@gmail.com","commits":1,"url":"https://github.com/Hertz"}]},"readingTime":{"minutes":4.16,"words":1249},"filePathRelative":"pl/rust/2-basic.md","localizedDate":"2024年8月2日","excerpt":"<h2>1 数据</h2>\\n<h3>1.1 数据和类型</h3>\\n<figure><img src=\\"/images/rust/datastructure.webp\\" alt=\\"\\" width=\\"500\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption></figcaption></figure>\\n<h3>1.2 指针和引用</h3>\\n<p>指针即内存地址，可以通过解引用（dereference）来访问它指向的内存地址。理论上可以解引用到任意数据类型。</p>\\n<p>引用（reference）类似指针。不同之处在于，引用的解引用访问受限，只能解引用到它引用数据的类型。如 42u8 这个值的引用，它解引用只能使用 u8 数据类型。</p>"}');
export {
  _2Basic_html as comp,
  data
};
