import { c as createElementBlock, b as createStaticVNode, o as openBlock } from "./app-BO1sXcn2.js";
import { _ as _export_sfc } from "./plugin-vue_export-helper-1tPrXgE0.js";
const _imports_0 = "/images/rust/memory.webp";
const _imports_1 = "/images/rust/callstack.webp";
const _sfc_main = {};
function _sfc_render(_ctx, _cache) {
  return openBlock(), createElementBlock("div", null, _cache[0] || (_cache[0] = [
    createStaticVNode('<h2 id="_1-内存" tabindex="-1"><a class="header-anchor" href="#_1-内存"><span>1. 内存</span></a></h2><p>先看这样一个例子：</p><div class="language-rust line-numbers-mode" data-highlighter="prismjs" data-ext="rs" data-title="rs"><pre><code><span class="line"><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">&quot;hello world&quot;</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>\n<span class="line"><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;addr of ss: {:p}, s: {:p}, len: {}, capacity: {}, size: {}&quot;</span><span class="token punctuation">,</span></span>\n<span class="line">        <span class="token operator">&amp;</span><span class="token string">&quot;hello world&quot;</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>s<span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token namespace">std<span class="token punctuation">::</span>mem<span class="token punctuation">::</span></span><span class="token function">size_of_val</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>\n<span class="line"><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;字符串常量获得固定的内存地址 {:p}&quot;</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token string">&quot;hello world&quot;</span><span class="token punctuation">)</span></span>\n<span class="line"></span>\n<span class="line"><span class="token comment">// addr of ss: 0x5562fb6903f8, s: 0x7fff7db37d58, len: 11, capacity: 11, size: 24</span></span>\n<span class="line"><span class="token comment">// 字符串常量获得固定的内存地址 0x5562fb6903f8</span></span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li><p>“hello world” 是字符串常量（string literal），在编译时被存入可执行文件的 .RODATA 段（GCC）或 .RDATA 段（VC++）。程序加载时，会获得一个固定的内存地址。</p></li><li><p>执行 <code>&quot;hello world&quot;.to_string()</code> 时，在堆上分配新的内存，把 “hello world” 逐字节拷贝过去。</p></li><li><p>把堆上的数据复制给 <code>s</code> 时，<code>s</code> 作为分配在栈上的变量，它需要知道堆上对应的内存地址。由于堆上的数据大小不确定且可以增长，所以还需要知道它的长度以及它现在有多大。</p></li></ol><p>如下图所示，为了表达这个字符串使用了 3 个字（word）：指针、字符串当前长度（11）、对应内存的容量（11）。在 64 位系统下，三个 word 是 24 字节。</p><figure><img src="' + _imports_0 + '" alt="" width="500" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="_2-栈和堆" tabindex="-1"><a class="header-anchor" href="#_2-栈和堆"><span>2. 栈和堆</span></a></h2><h3 id="_2-1-栈" tabindex="-1"><a class="header-anchor" href="#_2-1-栈"><span>2.1 栈</span></a></h3><p>栈是程序运行的基础。栈帧是分配在调用栈（Call Stack）上的一块内存区域，当一个函数被调用时，一块连续的内存就会在栈顶被分配出来，这块内存被称为栈帧（Stack Frame）。</p><p>栈自顶向下增长，一个程序调用战斗的最底部，除去入口帧（entry frame），就是 main() 函数对应的帧。随着函数一层层嗲用，栈会一层层扩展；调用结束，栈又会一层层回溯，释放内存。</p><figure><img src="' + _imports_1 + '" alt="" width="500" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>某个栈帧要有多大呢？编译器在编译并优化代码时，一个函数就是一个最小的编译单元。在一个函数中，编译器必须知道要用到哪些寄存器、栈上要放哪些局部变量，这些都在编译时确定，以便预留空间。</p><p>所以，<strong>在编译时，一切无法确定大小或者大小可以改变的数据，都无法安全地放在栈上，最好放在堆上。</strong></p><h4 id="栈的使用" tabindex="-1"><a class="header-anchor" href="#栈的使用"><span>栈的使用</span></a></h4><p>栈上的内存分配是非常高效的：改动栈指针（Stack Pointer）就可以预留相应的空间；把栈指针改回来，预留的空间就会被释放掉。预留和释放只是改动寄存器，不涉及额外计算、不涉及系统调用，效率很高。</p><p>所以，在保证栈空间足够的前提下，应尽可能使用栈内存来换高性能执行。比如很多内存分配模块都提供了可选地内训位置，如栈、固定大小的内存池（来自于堆）。</p><p>但是在实际工作中，考虑到调用栈的大小，避免栈溢出（Stack Overflow），我们又要避免把大量的数据分配在栈上。</p><h3 id="_2-2-堆" tabindex="-1"><a class="header-anchor" href="#_2-2-堆"><span>2.2 堆</span></a></h3><h4 id="_2-2-1-动态大小的内存分配到堆上" tabindex="-1"><a class="header-anchor" href="#_2-2-1-动态大小的内存分配到堆上"><span>2.2.1 动态大小的内存分配到堆上</span></a></h4><p>当需要动态大小的内存时，只能使用堆。如可变长度的数组、列表、哈希表、字典等。</p><p>堆上分配内存时，一般都会预留一些空间，这是最佳实践。</p><p>比如创建一个列表</p><div class="language-rust" data-highlighter="prismjs" data-ext="rs" data-title="rs"><pre><code><span class="line"><span class="token keyword">let</span> <span class="token keyword">mut</span> arr <span class="token operator">=</span> <span class="token class-name">Vec</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>\n<span class="line">arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>\n<span class="line">arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>\n<span class="line"></span></code></pre></div><p>这个列表实际预留的大小是 4，而不是其长度 2。如果不预留空间、需要多少就分配多少，那么每次新增值，都要新分配一大块内存，先拷贝已有数据，再把新值加进去，最后释放旧的内存。这样效率很低。</p><blockquote><p>堆上内存分配会使用 libc 提供的 malloc() 函数，其内部会请求操作系统的系统调用来分配内存。系统调用代价高昂，我们要避免频繁使用 malloc()。</p></blockquote><h4 id="_2-2-1-动态生命周期的内存分配到堆上" tabindex="-1"><a class="header-anchor" href="#_2-2-1-动态生命周期的内存分配到堆上"><span>2.2.1 动态生命周期的内存分配到堆上</span></a></h4><p>栈帧会在函数调用结束后被回收，相关变量对应的内存也都被回收。所以栈上内存的生命周期是不受开发者控制的，并且局限在当前调用栈。</p><p>而堆上分配出的每一块内存需要显示释放，于是堆上内存有更灵活的生命周期，可以在不同的调用栈之间共享数据。</p><h4 id="堆的使用" tabindex="-1"><a class="header-anchor" href="#堆的使用"><span>堆的使用</span></a></h4><p>堆内存的灵活性也给内存管理带来很多挑战。</p><p>如果手工管理堆内存的话，堆上内存分配后忘记释放，就会造成<strong>内存泄漏</strong>。</p><p>如果堆上内存被多个线程的调用栈引用，该内存的改动要特别小心，需要加锁以独占访问，来避免潜在的问题。比如说，一个线程在遍历列表，而另一个线程在释放列表中的某一项，就可能访问野指针，导致<strong>堆越界</strong>（heap out of bounds）。而堆越界是第一大内存安全问题。</p><p>如果堆上内存被释放，但栈上指向堆上内存的相应指针没有被清空，就有可能发生<strong>使用已释放内存</strong>（use after free）的情况，程序轻则崩溃，重则隐含安全隐患。根据<a href="https://github.com/Microsoft/MSRC-Security-Research/blob/master/presentations/2019_02_BlueHatIL/2019_01%20-%20BlueHatIL%20-%20Trends%2C%20challenge%2C%20and%20shifts%20in%20software%20vulnerability%20mitigation.pdf" target="_blank" rel="noopener noreferrer">微软安全反应中心（MSRC）的研究</a>，这是第二大内存安全问题。</p><h2 id="_3-垃圾回收" tabindex="-1"><a class="header-anchor" href="#_3-垃圾回收"><span>3. 垃圾回收</span></a></h2><h3 id="gc-和-arc" tabindex="-1"><a class="header-anchor" href="#gc-和-arc"><span>GC 和 ARC</span></a></h3><p>为了避免堆内存手动管理造成的问题，以 Java 为首的一系列编程语言，采用追踪式垃圾回收（<a href="https://zh.javascript.info/garbage-collection#nei-bu-suan-fa" target="_blank" rel="noopener noreferrer">Tracing GC</a>）方法来自动管理内存。通过定期标记（mark）找出不可达对象，然后将其清理（sweep）掉。</p><p>ObjC 和 Swift 则使用自动引用计数（Automatic Reference Counting）方法。在编译时，为每个函数插入 retain/release 语句来自动维护堆上对象的引用计数，当引用计数为零时，release 语句就释放对象。</p><h3 id="对比" tabindex="-1"><a class="header-anchor" href="#对比"><span>对比</span></a></h3><p>效率上，GC 在内存分配和释放上没有额外操作。而 ARC 添加了大量额外代码来处理引用计数。所以 GC 效率更高，吞吐量（throughput）更大。</p><p>但是，GC 释放内存的时机不确定，释放时引发的 STW（Stop the World）也会导致代码执行的延迟（latency）不确定。所以，<strong>一般携带 GC 的编程语言，不适合做嵌入式系统或实时系统</strong>。</p><p>使用 Android 手机偶尔感觉卡顿，而 iOS 却运行丝滑，大多是这个原因。而且做后端服务时，API 或者服务响应时间的 p99（99th percentile，一组数据中最差的 1% 的情况）也会受到 GC STW 的影响而表现不佳。</p><p>GC 分配和释放内存的效率和吞吐量要比 ARC 高，<strong>但因为偶尔的高延迟，导致被感知的性能比较差</strong>，所以会给人一种 GC 不如 ARC 性能好的感觉。</p><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结"><span>小结</span></a></h2><ul><li>栈中存放的数据是静态的、固定大小、固定生命周期；堆上存放的数据是动态的、不固定大小、不固定生命周期。 <ul><li>对于存入栈的值，它的大小在编译时就要确定。栈上存储的变量，生命周期在当前调用栈的作用域内，无法跨调用栈引用。</li><li>堆可以存入大小未知或动态伸缩的数据类型。堆上存储的变量，起盛宁周期从分配后开始，一直到释放时才结束。因此堆上的变量允许在多个调用栈之间引用。但也导致堆变量的管理非常复杂，手工管理会引发很多内存安全性问题，而自动管理，无论是 GC 还是 ARC，都有性能损耗和其它问题。</li></ul></li></ul>', 44)
  ]));
}
const _1Memory_html = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__file", "1-memory.html.vue"]]);
const data = JSON.parse('{"path":"/pl/rust/1-memory.html","title":"内存","lang":"zh-CN","frontmatter":{"lang":"zh-CN","title":"内存","description":null,"article":false,"date":"2024-08-01T00:00:00.000Z","order":1},"headers":[{"level":2,"title":"1. 内存","slug":"_1-内存","link":"#_1-内存","children":[]},{"level":2,"title":"2. 栈和堆","slug":"_2-栈和堆","link":"#_2-栈和堆","children":[{"level":3,"title":"2.1 栈","slug":"_2-1-栈","link":"#_2-1-栈","children":[{"level":4,"title":"栈的使用","slug":"栈的使用","link":"#栈的使用","children":[]}]},{"level":3,"title":"2.2 堆","slug":"_2-2-堆","link":"#_2-2-堆","children":[{"level":4,"title":"2.2.1 动态大小的内存分配到堆上","slug":"_2-2-1-动态大小的内存分配到堆上","link":"#_2-2-1-动态大小的内存分配到堆上","children":[]},{"level":4,"title":"2.2.1 动态生命周期的内存分配到堆上","slug":"_2-2-1-动态生命周期的内存分配到堆上","link":"#_2-2-1-动态生命周期的内存分配到堆上","children":[]},{"level":4,"title":"堆的使用","slug":"堆的使用","link":"#堆的使用","children":[]}]}]},{"level":2,"title":"3. 垃圾回收","slug":"_3-垃圾回收","link":"#_3-垃圾回收","children":[{"level":3,"title":"GC 和 ARC","slug":"gc-和-arc","link":"#gc-和-arc","children":[]},{"level":3,"title":"对比","slug":"对比","link":"#对比","children":[]}]},{"level":2,"title":"小结","slug":"小结","link":"#小结","children":[]}],"git":{"createdTime":1735022911000,"updatedTime":1735022911000,"contributors":[{"name":"Hertz","username":"Hertz","email":"hanzhuosoul@gmail.com","commits":1,"url":"https://github.com/Hertz"}]},"readingTime":{"minutes":6.52,"words":1957},"filePathRelative":"pl/rust/1-memory.md","localizedDate":"2024年8月1日","excerpt":"<h2>1. 内存</h2>\\n<p>先看这样一个例子：</p>\\n<div class=\\"language-rust line-numbers-mode\\" data-highlighter=\\"prismjs\\" data-ext=\\"rs\\" data-title=\\"rs\\"><pre><code><span class=\\"line\\"><span class=\\"token keyword\\">let</span> s <span class=\\"token operator\\">=</span> <span class=\\"token string\\">\\"hello world\\"</span><span class=\\"token punctuation\\">.</span><span class=\\"token function\\">to_string</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span></span>\\n<span class=\\"line\\"><span class=\\"token macro property\\">println!</span><span class=\\"token punctuation\\">(</span><span class=\\"token string\\">\\"addr of ss: {:p}, s: {:p}, len: {}, capacity: {}, size: {}\\"</span><span class=\\"token punctuation\\">,</span></span>\\n<span class=\\"line\\">        <span class=\\"token operator\\">&amp;</span><span class=\\"token string\\">\\"hello world\\"</span><span class=\\"token punctuation\\">,</span> <span class=\\"token operator\\">&amp;</span>s<span class=\\"token punctuation\\">,</span> s<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">len</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">,</span> s<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">capacity</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">,</span> <span class=\\"token namespace\\">std<span class=\\"token punctuation\\">::</span>mem<span class=\\"token punctuation\\">::</span></span><span class=\\"token function\\">size_of_val</span><span class=\\"token punctuation\\">(</span><span class=\\"token operator\\">&amp;</span>s<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span></span>\\n<span class=\\"line\\"><span class=\\"token macro property\\">println!</span><span class=\\"token punctuation\\">(</span><span class=\\"token string\\">\\"字符串常量获得固定的内存地址 {:p}\\"</span><span class=\\"token punctuation\\">,</span> <span class=\\"token operator\\">&amp;</span><span class=\\"token string\\">\\"hello world\\"</span><span class=\\"token punctuation\\">)</span></span>\\n<span class=\\"line\\"></span>\\n<span class=\\"line\\"><span class=\\"token comment\\">// addr of ss: 0x5562fb6903f8, s: 0x7fff7db37d58, len: 11, capacity: 11, size: 24</span></span>\\n<span class=\\"line\\"><span class=\\"token comment\\">// 字符串常量获得固定的内存地址 0x5562fb6903f8</span></span>\\n<span class=\\"line\\"></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>"}');
export {
  _1Memory_html as comp,
  data
};
