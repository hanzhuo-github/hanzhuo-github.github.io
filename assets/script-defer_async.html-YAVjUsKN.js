import { c as createElementBlock, b as createStaticVNode, a as createCommentVNode, o as openBlock } from "./app-BO1sXcn2.js";
import { _ as _export_sfc } from "./plugin-vue_export-helper-1tPrXgE0.js";
const _sfc_main = {};
function _sfc_render(_ctx, _cache) {
  return openBlock(), createElementBlock("div", null, [
    _cache[0] || (_cache[0] = createStaticVNode("<p>当浏览器遇到 <code>&lt;script&gt;</code> 时，它必须先处理该脚本，对于外部脚本 <code>&lt;script src=&quot;...&quot;&gt;</code> 也一样，必须先等脚本下载完并执行结束，然后才能继续构建 DOM。</p><p>于是，如果页面的顶部有一个需要长时间运行的脚本，它会阻塞页面，用户要等到脚本执行完才能看到页面。另外，脚本不能访问位于它下面的元素。</p><p><code>&lt;script&gt;</code> 中的两个特性 <code>defer</code> 和 <code>async</code> 可以解决这个问题。</p>", 3)),
    createCommentVNode(" more "),
    _cache[1] || (_cache[1] = createStaticVNode('<h2 id="_1-defer" tabindex="-1"><a class="header-anchor" href="#_1-defer"><span>1. defer</span></a></h2><p><code>defer</code> 特性告诉浏览器不要等待脚本，让浏览器继续处理 HTML，构建 DOM。脚本会在后台下载，等 DOM 构建完成后，再执行脚本。它有以下特性：</p><ul><li><code>defer</code> 属性的脚本不会阻塞页面</li><li><code>defer</code> 属性的脚本在 DOM 解析完毕后，<code>DOMContentLoaded</code> 事件前执行。</li><li><code>defer</code> 属性的脚本的执行保持相对顺序</li></ul><div class="language-html line-numbers-mode" data-highlighter="prismjs" data-ext="html" data-title="html"><pre><code><span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>script 前<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span></span>\n<span class="line"></span>\n<span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript"></span>\n<span class="line">  document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;DOMContentLoaded&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span></span>\n<span class="line">    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;DOM ready after defer!&quot;</span><span class="token punctuation">)</span></span>\n<span class="line">  <span class="token punctuation">)</span><span class="token punctuation">;</span></span>\n<span class="line"></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></span>\n<span class="line"></span>\n<span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">defer</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/path/to/script/1<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></span>\n<span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">defer</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/path/to/script/2<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></span>\n<span class="line"></span>\n<span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>script 后<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span></span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码会立刻显示页面内容。然后处理有 <code>defer</code> 属性的脚本，等它们完成后（按照代码中的顺序，先执行脚本 1，再执行脚本 2），<code>DOMContentLoaded</code> 事件被触发。</p><p>脚本 1 和脚本 2 可以是并行下载的，无论谁先下载完，都必须是 1 先执行，2 后执行。</p><h2 id="_2-async" tabindex="-1"><a class="header-anchor" href="#_2-async"><span>2. async</span></a></h2><p><code>async</code> 也是为了让脚本不阻塞页面，但它是完全独立的。</p><ul><li>浏览器不会因 <code>async</code> 脚本阻塞页面（同 <code>defer</code>）</li><li>其他脚本不会等待 <code>async</code> 脚本，<code>async</code> 脚本也不会等待其他脚本</li><li><code>DOMContentLoaded</code> 和 <code>async</code> 脚本不会互相等待</li></ul><p><code>async</code> 脚本在后台加载，加载完成后立即执行。DOM 和其他脚本都不会等待 <code>async</code> 脚本，<code>async</code> 脚本也不会等待其他东西。它就是一个加载完就执行的完全独立的脚本。</p><p>它的执行顺序与引用的顺序无关，只和代码加载完成的顺序有关，谁先加载完谁就先执行。</p><div class="hint-container info"><p class="hint-container-title"><code>defer</code> 只适用于外部脚本</p><p>如果 <code>&lt;script&gt;</code> 没有 <code>src</code>，那么 <code>defer</code> 和 <code>async</code> 都会被忽略。</p><p>但是，<code>async</code> 也可以用于模块脚本。即 <code>&lt;script async type=&quot;module&quot;&gt;&lt;/script&gt;</code> 也是可以的。</p></div><h2 id="_3-动态脚本" tabindex="-1"><a class="header-anchor" href="#_3-动态脚本"><span>3. 动态脚本</span></a></h2><p>如果使用 JavaScript 动态创建一个脚本，并将其附加到文档中：</p><div class="language-javascript" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token keyword">const</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">&quot;script&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>\n<span class="line">script<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">&quot;/path/to/script&quot;</span><span class="token punctuation">;</span></span>\n<span class="line">document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 文档被附加到文档中，脚本立刻开始加载</span></span>\n<span class="line"></span></code></pre></div><p>这种情况下，当文档被附加到文档中时，脚本就开始加载。这种动态脚本的行为是异步的（相当于设置了 <code>async</code>）：</p><ul><li>它们不会等待任何东西，其它东西也不会等它们</li><li>先加载完的脚本先执行</li></ul><p>如果显示设置了 <code>script.async=false</code>，这个脚本的行为相当于 <code>defer</code>，它要按照脚本在文档中的顺序去执行。</p><h2 id="_4-总结" tabindex="-1"><a class="header-anchor" href="#_4-总结"><span>4. 总结</span></a></h2><table><thead><tr><th></th><th>顺序</th><th>DOMContentLoaded</th></tr></thead><tbody><tr><td>async</td><td>加载优先。脚本在文档中的顺序不重要 —— 先加载完成的先执行</td><td>不相关。可能在文档加载完成前加载并执行完毕。如果脚本很小或者来自于缓存，同时文档足够长，就会发生这种情况。</td></tr><tr><td>defer</td><td>在文档中的顺序</td><td>在文档加载和解析完成之后，在 DOMContentLoaded 之前执行。</td></tr></tbody></table>', 20))
  ]);
}
const scriptDefer_async_html = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__file", "script-defer_async.html.vue"]]);
const data = JSON.parse('{"path":"/front-end/browser/script-defer_async.html","title":"script 中的 defer 和 async","lang":"zh-CN","frontmatter":{"lang":"zh-CN","title":"script 中的 defer 和 async","description":null,"article":false,"date":"2023-11-11T00:00:00.000Z","order":2},"headers":[{"level":2,"title":"1. defer","slug":"_1-defer","link":"#_1-defer","children":[]},{"level":2,"title":"2. async","slug":"_2-async","link":"#_2-async","children":[]},{"level":2,"title":"3. 动态脚本","slug":"_3-动态脚本","link":"#_3-动态脚本","children":[]},{"level":2,"title":"4. 总结","slug":"_4-总结","link":"#_4-总结","children":[]}],"git":{"createdTime":1735022911000,"updatedTime":1735022911000,"contributors":[{"name":"Hertz","username":"Hertz","email":"hanzhuosoul@gmail.com","commits":1,"url":"https://github.com/Hertz"}]},"readingTime":{"minutes":2.86,"words":858},"filePathRelative":"front-end/browser/script-defer&async.md","localizedDate":"2023年11月11日","excerpt":"<p>当浏览器遇到 <code>&lt;script&gt;</code> 时，它必须先处理该脚本，对于外部脚本 <code>&lt;script src=\\"...\\"&gt;</code> 也一样，必须先等脚本下载完并执行结束，然后才能继续构建 DOM。</p>\\n<p>于是，如果页面的顶部有一个需要长时间运行的脚本，它会阻塞页面，用户要等到脚本执行完才能看到页面。另外，脚本不能访问位于它下面的元素。</p>\\n<p><code>&lt;script&gt;</code> 中的两个特性 <code>defer</code> 和 <code>async</code> 可以解决这个问题。</p>\\n"}');
export {
  scriptDefer_async_html as comp,
  data
};
