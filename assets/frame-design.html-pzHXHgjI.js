import { c as createElementBlock, b as createStaticVNode, o as openBlock } from "./app-BO1sXcn2.js";
import { _ as _export_sfc } from "./plugin-vue_export-helper-1tPrXgE0.js";
const _sfc_main = {};
function _sfc_render(_ctx, _cache) {
  return openBlock(), createElementBlock("div", null, _cache[0] || (_cache[0] = [
    createStaticVNode('<h2 id="_1-命令式-v-s-声明式" tabindex="-1"><a class="header-anchor" href="#_1-命令式-v-s-声明式"><span>1 命令式 v.s. 声明式</span></a></h2><p>视图层框架通常分为命令式（关注过程，如 JQuery）和声明式。</p><p>声明式代码的性能不优于命令式代码的性能。这不难理解，命令式代码可以直接用相关命令来进行对应操作；而声明式代码为了更优的性能，需要先找出代码差异只更新最新变化之处，最后仍然是要进行对应操作（这一步和命令式代码相同）。</p><p>但是，声明式代码的可维护性更强。框架的设计要保持可维护性，同时最小化性能损失。</p><h2 id="_2-虚拟-dom-的性能" tabindex="-1"><a class="header-anchor" href="#_2-虚拟-dom-的性能"><span>2 虚拟 DOM 的性能</span></a></h2><p>声明式代码的更新性能消耗 = 找出差异的性能消耗 + 直接修改的性能消耗</p><p>虚拟 DOM 就是为了最小化找出差异的性能消耗。</p><p>对比一下虚拟 DOM 和 innerHTML 模板的性能。（1）创建页面时，虚拟 DOM 需要创建 JavaScript 对象（VNode），然后新建所有 DOM 元素；innerHTML 需要渲染 HTML 字符串，然后新建所有 DOM 元素。（2）更新页面时，innerHTML 仍然要渲染 HTML 字符串，然后<strong>销毁所有旧 DOM，新建所有新 DOM</strong>；而虚拟 DOM 只需要进行<strong>必要的 DOM 更新</strong>，在此之前，它会创建新的 JavaScript 对象，并进行 Diff。</p><p>更新页面时，虚拟 DOM 的性能主要与数据变化量相关，而 innerHTML 的性能与模板大小相关。如果 innerHTML 模板很大，且只有少量更新，那它的性能显然更差。</p><h2 id="_3-运行时、编译时" tabindex="-1"><a class="header-anchor" href="#_3-运行时、编译时"><span>3 运行时、编译时</span></a></h2><p>运行时：假设我们设计了一个框架，它提供了一个 Render 函数，它接收一个树形结构的数据对象，根据该对象递归地将数据渲染成 DOM 元素。</p><p>用户在使用这个框架时，会觉得写树形结构的数据对象不直观，能不能用类似 HTML 标签的方式来描述这个树形结构的数据对象呢。</p><p>为了满足这种需求，我们可以引入编译手段，将 HTML 标签编译成树形结构的数据对象，这样就可以继续使用 Render 函数了。于是，我们写了一个 Compiler 函数，来讲 HTML 字符串编译成树形结构的数据对象。</p><p>这样，就可以写 HTML 标签，然后以此调用 Compiler、Render 函数。这时，就实现了一个运行时 + 编译时的框架。</p><h2 id="_4-tree-shaking" tabindex="-1"><a class="header-anchor" href="#_4-tree-shaking"><span>4 Tree-Shaking</span></a></h2><p>框架要做到良好的 Tree-Shaking。Tree-Shaking 就是消除永远不会被执行的代码（即 dead code），rollup 和 webpack 都支持 Tree-Shaking。</p><p>实现 Tree-Shaking 是有前提的，要求模块必须是 ESM (ES Module)，因为 Tree-Shaking 依赖 ESM 的静态结构。</p><p>在函数调用时（一般是顶级调用）使用 <code>/*#__PURE__*/</code> 来表明这是纯函数，不会有任何副作用，这样 Tree-Shaking 就会将这段代码移除掉。</p><h2 id="_5-框架构建的产物" tabindex="-1"><a class="header-anchor" href="#_5-框架构建的产物"><span>5 框架构建的产物</span></a></h2><ol><li>IIFE（Immediately Invoked Function Expression，立即调用函数表达式）</li></ol><p>配置：<code>format: &#39;iifl&#39;</code></p><p>使用：<code>&lt;script src=&quot;/path/to/vue.js&quot;&gt;&lt;/script&gt;</code> Vue 的输出文件：vue.global.js</p><ol start="2"><li>ESM</li></ol><p>有两种 ESM：</p><ul><li>用于浏览器的 esm-browser.js <ul><li>使用：<code>&lt;script type=&quot;module&quot; src=&quot;/path/to/vue.esm-browser.js&quot;&gt;&lt;/script&gt;</code></li><li>将预定义常量 <code>_DEV_</code> 替换为字面量 true 或 false</li></ul></li><li>用于打包工具的 esm-bundler.js <ul><li>使用：在配置中指定路径 <code>&quot;module&quot;: &quot;dist/vue.runtime.esm-bundler.js&quot;</code>（如果 package.json 中存在 module 字段，会优先使用 module 字段指向的资源来代替 main 指向的资源）</li><li>将预定义常量 <code>_DEV_</code> 替换为 <code>process.env.MPDE_ENV !== &#39;production&#39;</code> 语句</li></ul></li></ul><p>配置：</p><ul><li><code>format: &#39;esm&#39;</code></li><li><code>&quot;main&quot;: &quot;index.js&quot;</code></li><li><code>&quot;module&quot;: &quot;dist/vue.runtime.esm-bundler.js&quot;</code></li></ul><ol start="3"><li>CommonJS</li></ol><p>配置：<code>format: &#39;cjs&#39;</code></p><p>使用：服务端渲染（Vue.js 的代码在 Node.js 中运行，而非浏览器），能够使用 require 语句引用资源。<code>const Vue = require(&#39;vue&#39;)</code></p><h2 id="_6-vue" tabindex="-1"><a class="header-anchor" href="#_6-vue"><span>6 Vue</span></a></h2><p>Vue.js 声明式描述 UI，既可以使用模板，也可以使用虚拟 DOM</p><ul><li><p>渲染器：把虚拟 DOM 对象渲染为真实 DOM 元素</p><ul><li>原理：递归遍历虚拟 DOM 对象，调用原生 DOM API 完成真实 DOM 的创建</li><li>精髓：更新，通过 Diff 算法找出变更点，只会更新需要更新的内容</li></ul></li><li><p>编译器：将模板编译为渲染函数</p></li><li><p>组件的本质：一组 DOM 元素的封装。可以是一个返回虚拟 DOM 的函数，也可以是一个对象（这个对象下必须要有一个函数来产出组件要渲染的虚拟 DOM）</p></li></ul><p>Vue.js 回味开发环境和生产环境输出不同的包。vue.global.js 用于开发环境，包含必要的警告信息；vue.global.prod.js 用于生产环境，不包含警告信息。</p>', 34)
  ]));
}
const frameDesign_html = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__file", "frame-design.html.vue"]]);
const data = JSON.parse('{"path":"/front-end/vue/frame-design.html","title":"框架设计","lang":"zh-CN","frontmatter":{"lang":"zh-CN","title":"框架设计","description":null,"article":false,"date":"2024-10-01T00:00:00.000Z","order":1},"headers":[{"level":2,"title":"1 命令式 v.s. 声明式","slug":"_1-命令式-v-s-声明式","link":"#_1-命令式-v-s-声明式","children":[]},{"level":2,"title":"2 虚拟 DOM 的性能","slug":"_2-虚拟-dom-的性能","link":"#_2-虚拟-dom-的性能","children":[]},{"level":2,"title":"3 运行时、编译时","slug":"_3-运行时、编译时","link":"#_3-运行时、编译时","children":[]},{"level":2,"title":"4 Tree-Shaking","slug":"_4-tree-shaking","link":"#_4-tree-shaking","children":[]},{"level":2,"title":"5 框架构建的产物","slug":"_5-框架构建的产物","link":"#_5-框架构建的产物","children":[]},{"level":2,"title":"6 Vue","slug":"_6-vue","link":"#_6-vue","children":[]}],"git":{"createdTime":1735022911000,"updatedTime":1735022911000,"contributors":[{"name":"Hertz","username":"Hertz","email":"hanzhuosoul@gmail.com","commits":1,"url":"https://github.com/Hertz"}]},"readingTime":{"minutes":3.89,"words":1166},"filePathRelative":"front-end/vue/frame-design.md","localizedDate":"2024年10月1日","excerpt":"<h2>1 命令式 v.s. 声明式</h2>\\n<p>视图层框架通常分为命令式（关注过程，如 JQuery）和声明式。</p>\\n<p>声明式代码的性能不优于命令式代码的性能。这不难理解，命令式代码可以直接用相关命令来进行对应操作；而声明式代码为了更优的性能，需要先找出代码差异只更新最新变化之处，最后仍然是要进行对应操作（这一步和命令式代码相同）。</p>\\n<p>但是，声明式代码的可维护性更强。框架的设计要保持可维护性，同时最小化性能损失。</p>\\n<h2>2 虚拟 DOM 的性能</h2>\\n<p>声明式代码的更新性能消耗 = 找出差异的性能消耗 + 直接修改的性能消耗</p>\\n<p>虚拟 DOM 就是为了最小化找出差异的性能消耗。</p>"}');
export {
  frameDesign_html as comp,
  data
};
