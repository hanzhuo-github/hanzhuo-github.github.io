import { c as createElementBlock, b as createStaticVNode, o as openBlock } from "./app-BO1sXcn2.js";
import { _ as _export_sfc } from "./plugin-vue_export-helper-1tPrXgE0.js";
const _sfc_main = {};
function _sfc_render(_ctx, _cache) {
  return openBlock(), createElementBlock("div", null, _cache[0] || (_cache[0] = [
    createStaticVNode('<h2 id="_1-模块系统" tabindex="-1"><a class="header-anchor" href="#_1-模块系统"><span>1. 模块系统</span></a></h2><ul><li>Browser 支持 ES Module（ESM）</li><li>Node.js v11 以及以前的版本支持 CommonJS（CJS）</li><li>Node.js v12 及以后版本既支持 CJS 也支持 ESM</li></ul><h3 id="_1-1-commonjs" tabindex="-1"><a class="header-anchor" href="#_1-1-commonjs"><span>1.1 CommonJS</span></a></h3><p>CommonJS 是 Node.js 创造的一种模块化规范，旨在是 JavaScript 可以在服务端环境中使用。</p><p>在 CommonJS 中，每个文件都被视为一个模块，模块内部的代码不会自动暴露到全局作用域中，而要通过 <code>module.exports</code> 或 <code>exports</code> 来显式导出。</p><p>模块的引入通过 <code>require()</code> 来实现，使用其返回的对象来访问模块导出的内容。</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token comment">// math.js</span></span>\n<span class="line"><span class="token keyword">const</span> <span class="token function-variable function">add</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span></span>\n<span class="line"><span class="token keyword">const</span> <span class="token function-variable function">subtract</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span></span>\n<span class="line"></span>\n<span class="line">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span></span>\n<span class="line">  add<span class="token punctuation">,</span></span>\n<span class="line">  subtract<span class="token punctuation">,</span></span>\n<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>\n<span class="line"></span>\n<span class="line"><span class="token comment">// app.js</span></span>\n<span class="line"><span class="token keyword">const</span> math <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;./math&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>\n<span class="line">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>math<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span></span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-2-es-module" tabindex="-1"><a class="header-anchor" href="#_1-2-es-module"><span>1.2 ES Module</span></a></h3><p>ESM 是 ECMAScript 规范的一部分，在 ES6（ES2015）开始被引入到 JavaScript 中。</p><p>ESM 使用 <code>import</code> 和 <code>export</code> 来导入、导出模块。</p><p>ESM 使用静态结构，在编译时就能够确定模块之间的依赖关系，这使得工具可以进行更有效的优化和静态分析。</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token comment">// math.js</span></span>\n<span class="line"><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">add</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span></span>\n<span class="line"><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">subtract</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span></span>\n<span class="line"></span>\n<span class="line"><span class="token comment">// app.js</span></span>\n<span class="line"><span class="token keyword">import</span> <span class="token punctuation">{</span> add <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;./math&quot;</span><span class="token punctuation">;</span></span>\n<span class="line">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 5</span></span>\n<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>ESM 的演进：</p><ul><li>ES2015 是第一个引入了 <code>import</code> 和 <code>export</code> 到 JavaScript 语言的版本。</li><li>ES2020 添加了对 <code>import.meta</code> 和 <code>export * as ns from &quot;mod&quot;</code> 的支持。</li><li>ES2022 添加了对顶层 <code>await</code> 的支持。</li><li>ESnext 会随着 ECMAScript 规范的演进保持最新，包括和模块相关的 Stage 3+ 提案。</li></ul><h3 id="_1-3-node-js-对魔铠格式的检验" tabindex="-1"><a class="header-anchor" href="#_1-3-node-js-对魔铠格式的检验"><span>1.3 Node.js 对魔铠格式的检验</span></a></h3><p>Node.js v12 及之后的版本既支持 CJS 也支持 ESM，但是每个文件的格式是由其文件扩展名、最近的 <code>package.json</code> 文件中的 <code>&quot;type&quot;</code> 字段决定的。</p><ul><li><code>.mjs</code>/<code>.mts</code> 会被解释为 ES 模块，<code>.cjs</code>/<code>.cts</code> 会被解释为 CommonJS 模块</li><li>对于 <code>.js</code>/<code>.ts</code> 文件，查看最近的 <code>package.json</code> 文件中的 <code>&quot;type&quot;</code> 字段，如果是 <code>&quot;module&quot;</code>，则该文件被解释为 ES 模块，否则为 CommonJS 模块。</li></ul><p>如果文件被确定为 ES 模块，Node.js 在执行期间就不会注入 CommonJS 模块和 <code>require</code> 对象到文件的作用域中。所以如果尝试使用它们程序会报错。</p><h2 id="_2-esm-和-cjs-的互操作性" tabindex="-1"><a class="header-anchor" href="#_2-esm-和-cjs-的互操作性"><span>2. ESM 和 CJS 的互操作性</span></a></h2><p>ESM 和 CJS 是否能互相引入呢？CommonJS 并不是 ECMAScript 规范的一部分，因此自 ESM 在 2015 年被标准化以来，运行时环境、打包工具、转移器都可以使用自己的方案自由处理二者之间的互操作性问题，没有一套标准的互操作性规则。</p><p>目前已有的互操作性规则大致有以下三类：</p><ol><li>ESM-only：例如浏览器这类运行时环境，就只支持 ECMAScript Modules。</li><li>Bundler-like：在 JavaScript 引擎能够运行 ESM 之前，Babel 允许开发者将其转译为 CommonJS 模块。这些经过转译的 ESM 与手写的 CommonJS 之间的互操作性规则成为了打包工具和转译器的事实标准。</li><li>Node.js：在 Node.js 中， CommonJS 模块不能同步加载（使用 <code>require</code>）ES 模块，只能通过异步的 <code>import()</code> 来加载。ESM 可以默认导入 CommonJS 模块，而这些导入会绑定到 <code>exports</code> 对象上。</li></ol>', 22)
  ]));
}
const _1Module_html = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__file", "1-module.html.vue"]]);
const data = JSON.parse('{"path":"/front-end/configuration/1-module.html","title":"模块化规范","lang":"zh-CN","frontmatter":{"lang":"zh-CN","title":"模块化规范","description":null,"article":false,"date":"2023-12-20T00:00:00.000Z","order":1},"headers":[{"level":2,"title":"1. 模块系统","slug":"_1-模块系统","link":"#_1-模块系统","children":[{"level":3,"title":"1.1 CommonJS","slug":"_1-1-commonjs","link":"#_1-1-commonjs","children":[]},{"level":3,"title":"1.2 ES Module","slug":"_1-2-es-module","link":"#_1-2-es-module","children":[]},{"level":3,"title":"1.3 Node.js 对魔铠格式的检验","slug":"_1-3-node-js-对魔铠格式的检验","link":"#_1-3-node-js-对魔铠格式的检验","children":[]}]},{"level":2,"title":"2. ESM 和 CJS 的互操作性","slug":"_2-esm-和-cjs-的互操作性","link":"#_2-esm-和-cjs-的互操作性","children":[]}],"git":{"createdTime":1735022911000,"updatedTime":1735022911000,"contributors":[{"name":"Hertz","username":"Hertz","email":"hanzhuosoul@gmail.com","commits":1,"url":"https://github.com/Hertz"}]},"readingTime":{"minutes":2.68,"words":804},"filePathRelative":"front-end/configuration/1-module.md","localizedDate":"2023年12月20日","excerpt":"<h2>1. 模块系统</h2>\\n<ul>\\n<li>Browser 支持 ES Module（ESM）</li>\\n<li>Node.js v11 以及以前的版本支持 CommonJS（CJS）</li>\\n<li>Node.js v12 及以后版本既支持 CJS 也支持 ESM</li>\\n</ul>\\n<h3>1.1 CommonJS</h3>\\n<p>CommonJS 是 Node.js 创造的一种模块化规范，旨在是 JavaScript 可以在服务端环境中使用。</p>\\n<p>在 CommonJS 中，每个文件都被视为一个模块，模块内部的代码不会自动暴露到全局作用域中，而要通过 <code>module.exports</code> 或 <code>exports</code> 来显式导出。</p>"}');
export {
  _1Module_html as comp,
  data
};
